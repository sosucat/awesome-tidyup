#!/usr/bin/env python3
"""Extract filenames and scores from access HTML files and merge with tidyup_list.csv.

Usage: python -m src.awesome_tidyup.extract_access_scores -i data/input_access -t tidyup_list.csv -o access_scores.csv
The `-i` argument may be a single HTML file or a directory containing HTML files.

This script expects the tidyup_list.csv file to be generated by extract_tidyup.py.
"""
from __future__ import annotations

import argparse
import csv
import re
import sys
from html import unescape as html_unescape
from pathlib import Path

try:
    from bs4 import BeautifulSoup
except Exception:
    sys.exit("BeautifulSoup4 is required. Install with: pip install beautifulsoup4")


def extract_scores_from_html(path: Path):
    """Yield (filename, score) records parsed from a single HTML file `path`.
    Score extraction is heuristic: looks for elements with 'score' in class or numeric tokens in the same row as the filename.
    """
    html = path.read_text(encoding="utf-8", errors="ignore")
    soup = BeautifulSoup(html, "html.parser")

    # find rows that contain file entries â€” try several selectors seen in access HTML
    rows = soup.find_all("tr", attrs={"data-file-id": True})
    if not rows:
        # common Canvas export uses rows with class 'ir-list-item'
        rows = soup.find_all("tr", class_=re.compile(r"ir-list-item"))

    if not rows:
        # fallback: look for filename spans and score siblings in raw HTML
        for m in re.finditer(r'<span[^>]+ir-content-list-item-name-text-name[^>]*>(.*?)</span>', html, re.I | re.S):
            filename = re.sub(r'<[^>]+>', '', m.group(1)).strip()
            score = ""
            # prefer explicit feedback-score-indicator span following the filename
            start = m.end()
            block = html[start:start + 10000]  # look further ahead for the score element (handle large inline base64)
            block = html_unescape(block)
            mfb = re.search(r'<feedback-score-indicator[^>]*>.*?<span[^>]*>(\d{1,3}%).*?</span>', block, re.I | re.S)
            if mfb:
                score = mfb.group(1)
            else:
                # fallback: find any percent/number within the lookahead block
                ms = re.search(r'(\d{1,3}%|\d+\/\d+|\d+\.\d+|\b\d+\b)', block)
                if ms:
                    score = ms.group(1)
            if filename:
                yield {"filename": filename, "score": score}
        return

    for tr in rows:
        # filename: span with class 'ir-content-list-item-name-text-name'
        filename = ""
        fn_span = tr.find("span", class_=re.compile(r"ir-content-list-item-name-text-name"))
        if fn_span:
            filename = fn_span.get_text(strip=True)
        else:
            inp = tr.find("input", attrs={"data-filename": True})
            if inp and inp.has_attr("data-filename"):
                filename = inp["data-filename"].strip()

        # score: td with class 'ir-content-list-item-score' contains feedback-score-indicator
        score = ""
        score_td = tr.find("td", class_=re.compile(r"ir-content-list-item-score"))
        if score_td:
            # prefer the explicit span inside feedback-score-indicator
            fb = score_td.find(class_=re.compile(r'feedback-score-indicator'))
            if fb:
                sp = fb.find('span')
                if sp:
                    score = sp.get_text(strip=True)
                else:
                    # sometimes the span is inside a div inside the indicator
                    div = fb.find('div')
                    if div:
                        sp2 = div.find('span')
                        if sp2:
                            score = sp2.get_text(strip=True)
            if not score:
                # fallback: extract numeric token from the cell text
                score_text = score_td.get_text(separator=' ', strip=True)
                m = re.search(r'(\d{1,3}%|\d+\/\d+|\d+\.\d+|\b\d+\b)', score_text)
                if m:
                    score = m.group(1)
        else:
            # last-resort: scan the whole row text for a numeric token
            text = tr.get_text(separator=' ', strip=True)
            m = re.search(r'(\d{1,3}%|\d+\/\d+|\d+\.\d+|\b\d+\b)', text)
            if m:
                score = m.group(1)

        if filename:
            yield {"filename": filename, "score": score}


def load_tidyup_csv(path: Path):
    """Load tidyup CSV into a dict keyed by (course_number, filename)."""
    data = {}
    with open(path, encoding='utf-8') as fh:
        reader = csv.DictReader(fh)
        for row in reader:
            key = (row.get('course_number', '').strip(), row.get('filename', '').strip())
            data[key] = row
    return data


def main():
    p = argparse.ArgumentParser(description="Extract filenames and scores from access HTML files and merge with tidyup CSV")
    p.add_argument('-i', '--input', default='data/input_access', help='input HTML file or directory (default: data/input_access)')
    p.add_argument('-t', '--tidyup', default='tidyup_list.csv', help='path to tidyup_list.csv (default: tidyup_list.csv)')
    p.add_argument('-o', '--output', default='access_scores.csv', help='output CSV file path (default: access_scores.csv)')
    args = p.parse_args()

    in_path = Path(args.input)
    if not in_path.exists():
        print(f"Input path not found: {in_path}", file=sys.stderr)
        raise SystemExit(1)

    # collect html files
    html_files = []
    if in_path.is_file():
        html_files = [in_path]
    else:
        html_files = sorted([p for p in in_path.glob('*.html') if p.is_file()])

    # load tidyup csv
    tidyup = load_tidyup_csv(Path(args.tidyup))

    out_fieldnames = [
        'course_number', 'filename', 'access_restriction', 'used_in', 'last_updated', 'size', 'file_link', 'used_in_link', 'score'
    ]

    with open(args.output, 'w', newline='', encoding='utf-8') as outfh:
        writer = csv.DictWriter(outfh, fieldnames=out_fieldnames)
        writer.writeheader()

        for f in html_files:
            # derive course_number from filename: expecting access_<course>_*.html
            stem = f.stem
            parts = stem.split('_')
            course_number = parts[1] if len(parts) > 1 else stem

            for rec in extract_scores_from_html(f):
                filename = rec['filename']
                score = rec.get('score', '')
                key = (course_number, filename)
                tidy_row = tidyup.get(key, {})

                out = {
                    'course_number': course_number,
                    'filename': filename,
                    'access_restriction': tidy_row.get('access_restriction', ''),
                    'used_in': tidy_row.get('used_in', ''),
                    'last_updated': tidy_row.get('last_updated', ''),
                    'size': tidy_row.get('size', ''),
                    'file_link': tidy_row.get('file_link', ''),
                    'used_in_link': tidy_row.get('used_in_link', ''),
                    'score': score,
                }
                writer.writerow(out)

    print(f"Wrote merged CSV to {args.output}")


if __name__ == '__main__':
    main()
